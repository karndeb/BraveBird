import logging
import docker
import tarfile
import io
import os
import asyncio
from typing import Dict, Any, Optional
from pathlib import Path

from wsl_brain.core.config import settings

logger = logging.getLogger(__name__)

# This provides a safe, isolated environment to execute the Python scripts generated by the LLM for data extraction and processing tasks

class SecureCodingSandbox:
    """
    Provides a secure, ephemeral Docker environment for executing Python code.
    
    Role:
    - Isolates LLM-generated code execution from the main system.
    - specialized for Data Processing (pandas, openpyxl, etc.).
    - Mounts shared data volumes to allow processing of files downloaded 
      by the main Agent (if placed in the shared directory).
    """

    def __init__(self):
        self.client = docker.from_env()
        # We use a fat image with data science libs pre-installed to avoid pip install latency
        self.image = "python:3.10-slim" 
        self.container = None
        self.work_dir = "/workspace"
        
        # Ensure the shared data directory exists on the host
        self.host_data_dir = os.path.abspath("./data/agent_workspace")
        os.makedirs(self.host_data_dir, exist_ok=True)

    async def start(self):
        """
        Starts a persistent container that keeps running across multiple code blocks
        (to maintain state/variables), or starts fresh every time.
        For Agent S3, maintaining state within a task is usually preferred.
        """
        try:
            logger.info("ðŸ³ [CodingAgent] Spinning up Docker container...")
            
            # Pre-pull if missing
            try:
                self.client.images.get(self.image)
            except docker.errors.ImageNotFound:
                logger.info(f"Pulling image {self.image}...")
                self.client.images.pull(self.image)

            self.container = self.client.containers.run(
                self.image,
                command="tail -f /dev/null", # Keep alive
                detach=True,
                working_dir=self.work_dir,
                volumes={
                    self.host_data_dir: {'bind': self.work_dir, 'mode': 'rw'}
                },
                mem_limit="512m", # Hard limit to prevent OOM
                nano_cpus=1000000000, # 1 CPU core
                network_mode="none" # Security: No internet access by default
            )
            
            # Install dependencies needed for Agent S3 tasks
            # In production, build a custom Dockerfile instead of installing at runtime
            self._install_dependencies()
            
            logger.info(f"âœ… [CodingAgent] Container {self.container.short_id} ready.")
            return True
            
        except Exception as e:
            logger.error(f"âŒ [CodingAgent] Failed to start container: {e}")
            return False

    def _install_dependencies(self):
        """Quickly installs typical libs needed for office tasks."""
        # Note: This is slow. A better approach is building a custom Docker image.
        # For this assignment, we assume the base image might have them or we pip install.
        libs = ["pandas", "openpyxl", "beautifulsoup4", "lxml"]
        logger.info(f"ðŸ“¦ Installing dependencies: {', '.join(libs)}")
        res = self.container.exec_run(f"pip install {' '.join(libs)}", workdir=self.work_dir)
        if res.exit_code != 0:
            logger.warning(f"Dependency install warning: {res.output.decode()}")

    async def stop(self):
        """Kills and removes the container."""
        if self.container:
            try:
                self.container.kill()
                self.container.remove()
                logger.info("ðŸ›‘ [CodingAgent] Container cleaned up.")
            except Exception as e:
                logger.error(f"Error stopping container: {e}")

    async def execute_code(self, code: str, timeout: int = 30) -> Dict[str, Any]:
        """
        Executes a Python script inside the container.
        
        Args:
            code: The Python source code string.
            timeout: Max seconds to run.
            
        Returns:
            Dict containing stdout, stderr, and exit_code.
        """
        if not self.container:
            await self.start()

        logger.info("âš¡ [CodingAgent] Executing code snippet...")
        
        # 1. Write code to file inside container
        # We wrap the code in a wrapper to capture return values or handle errors gracefully if needed
        # But simple execution is usually enough.
        
        # Escape single quotes for shell heredoc
        safe_code = code.replace("'", "'\\''")
        
        setup_cmd = f"echo '{safe_code}' > script.py"
        self.container.exec_run(f"bash -c \"{setup_cmd}\"")

        # 2. Run the script
        # We use asyncio loop to make this non-blocking for the main thread
        loop = asyncio.get_event_loop()
        
        try:
            # Docker SDK exec_run is synchronous, so we wrap it
            def run_docker():
                return self.container.exec_run("python3 script.py")

            # Run in executor to support timeout
            exec_result = await asyncio.wait_for(
                loop.run_in_executor(None, run_docker),
                timeout=timeout
            )
            
            exit_code = exec_result.exit_code
            output = exec_result.output.decode("utf-8")
            
            logger.info(f"âœ… Execution done. Exit: {exit_code}")
            
            # Heuristic separation of stdout/stderr not perfectly supported by docker-py exec_run 
            # in simple mode, it merges them.
            return {
                "exit_code": exit_code,
                "stdout": output if exit_code == 0 else "",
                "stderr": output if exit_code != 0 else "",
                "status": "success" if exit_code == 0 else "error"
            }

        except asyncio.TimeoutError:
            logger.error("â° [CodingAgent] Code execution timed out!")
            # Attempt to kill the python process inside
            self.container.exec_run("pkill -9 python3")
            return {
                "exit_code": 124,
                "stdout": "",
                "stderr": f"Execution timed out after {timeout} seconds",
                "status": "timeout"
            }
        except Exception as e:
            logger.error(f"âŒ [CodingAgent] Execution exception: {e}")
            return {
                "exit_code": 1,
                "stdout": "",
                "stderr": str(e),
                "status": "error"
            }

    def write_file(self, filename: str, content: str):
        """Allows writing text files (like CSVs) into the workspace."""
        safe_content = content.replace("'", "'\\''")
        self.container.exec_run(f"bash -c \"echo '{safe_content}' > {filename}\"")

    def read_file(self, filename: str) -> Optional[str]:
        """Reads a file from the workspace (e.g., results.csv)."""
        try:
            # get_archive returns a tuple (raw_stream, stat)
            stream, stat = self.container.get_archive(filename)
            file_obj = io.BytesIO()
            for chunk in stream:
                file_obj.write(chunk)
            file_obj.seek(0)
            
            # Extract from tar
            with tarfile.open(fileobj=file_obj) as tar:
                member = tar.getmember(filename)
                f = tar.extractfile(member)
                return f.read().decode('utf-8')
        except Exception as e:
            logger.error(f"Failed to read file {filename}: {e}")
            return None